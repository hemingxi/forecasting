# -*- coding: utf-8 -*-
"""fpp-solutions-ch-8.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1SK-W4wCr-AQfpWWeIYSAkO4jZNvjVrFf

# Setup
"""

install.packages('fpp3')
install.packages('USgas')
install.packages('pryr')

library(data.table) 
library(fpp3)
library(readr)
library(USgas)
library(scales)
library(readxl)

"""# Qn 1

Consider the the number of pigs slaughtered in Victoria, available in the aus_livestock dataset.
"""

# head(aus_livestock)

vicpigs <- aus_livestock %>%
  filter(Animal == "Pigs", State == "Victoria")

# head(vicpigs)

pigs_fit <- vicpigs %>%
  model(ETS(Count ~ error("A") + trend("N") + season("N")))

pigs_fit %>% report()

pigs_fc <- pigs_fit %>% 
  forecast(h=4)

vicpigs %>% 
  filter(year(Month) >= 2010) %>%
  autoplot(Count) +
  autolayer(pigs_fc)

# Simple Exponential Smoothing gives us flat forecasts 
# calcucated as an exponentially decaying forecast of all the data points
# it's flat because we don't have any more actual data points with which to adjust our expectation

# head(pigs_fc)

pigs_fc %>% hilo(level = c(95))

sd <-sd(augment(pigs_fit)$.resid)
sd^2 # this is too low because we did not adjust for the two dof from estimated parameters
# we reassign it to what the model gives us
sd <- (glance(pigs_fit)$sigma2)^.5
# typeof(report(pigs_fit))

df <- pigs_fc %>%
  filter_index("2019-01") 

(ci = c(df$.mean - 1.96 * sd, df$.mean + 1.96 * sd))

# looks like our calculated CI is a bit narrower
# although based on ch 8.7, Table 8.8 it should be the same

"""# Qn 2, 3, 4

Write your own function to implement simple exponential smoothing. The function should take arguments y (the time series), alpha (the smoothing parameter α ) and level (the initial level ℓ0). It should return the forecast of the next observation in the series. Does it give the same forecast as ETS()?
"""

# testing the function

alpha = 0.3221247
level = 100646.6
y=vicpigs$Count

typeof(y)

n <- length(y)

indices <- seq(n-1,0,-1)
weights <- alpha * (1-alpha) ^ indices

(forecast_out <- y %*% weights + (1-alpha)^n) # this matches our output above

# writing the function

my_exp_smooth_pred <- function(par, data) {
  alpha <- par[1]
  levels <- par[2]
  y <- data 

  n <- length(y)

  indices <- seq(n-1,0,-1)
  weights <- alpha * (1-alpha) ^ indices

  forecast_out <- y %*% weights + (1-alpha)^n

  return(forecast_out)
}

my_exp_smooth_pred(par=c(0.3221247, 100646.6), data=vicpigs$Count)

# report(pigs_fit)

# class(pigs_fit)
# components(pigs_fit)
pigs_fit %>% tidy()
# this is how you'd get the model coefficients

# calculate the vector of predictions iteratively

my_exp_smooth_sse <- function(par, data) {
  alpha <- par[1]
  levels <- par[2]
  y <- data 

  n <- length(y)
  levels <- c() # create empty vector to append. The first prediction is missing

  for (i in seq(1:n)) {
    if (i == 1){
        level_i <- alpha * y[i] + (1 - alpha) * level
        levels <- append(levels, level_i)
    } else {
        level_i <- alpha * y[i] + (1 - alpha) * levels[i-1]
        levels <- append(levels, level_i)
    }
  }

  # predictions are the previous level parameter
  y_hat = c(level, levels[-n])

  errors <- y - y_hat
  sq_errors_out <- errors %*% errors

  return(sq_errors_out)
}

alpha = 0.3221247
level = 100646.6
y=vicpigs$Count

# my_exp_smooth_sse(y=vicpigs$Count, 0.3221247, 100646.6)
  n <- length(y)
  levels <- c() # create empty vector to append. The first prediction is missing

  for (i in seq(1:n)) {
    if (i == 1){
        level_i <- alpha * y[i] + (1 - alpha) * level
        levels <- append(levels, level_i)
    } else {
        level_i <- alpha * y[i] + (1 - alpha) * levels[i-1]
        levels <- append(levels, level_i)
    }
  }

  # predictions are the previous level parameter
  y_hat = c(level, levels[-n])

  errors <- y - y_hat
  sq_errors_out <- errors %*% errors

 # I think this is right!

  # check the tables look right
  # head(cbind(y, levels, y_hat))
  # head(components(pigs_fit))

  # check the SSE is correct
  sq_errors_out
  sum(components(pigs_fit)$remainder[-1] ^ 2)

  result <- optim(par=c(0.5, 100000), fn = my_exp_smooth_sse, data = vicpigs$Count )
  result

  # the results are close but it does not exactly match

my_sse <- function(data_in){
  result <- optim(par=c(0, 0), fn = my_exp_smooth_sse, data = data_in)

  prediction <- my_exp_smooth_pred(result$par, data_in)
  
  return(list(par = result$par, pred = prediction))

}

my_sse(vicpigs$Count)

"""# Qn 5"""

2# head(global_economy)

# global_economy %>% distinct(Country)

ec_can <- global_economy %>% 
  filter(Country == "Canada") 

ec_can %>% autoplot(Exports)

can_fit <- ec_can %>%
  model( ETS(Exports ~ error("A") + trend("N") + season("N")))

can_fc <- can_fit %>%
  forecast(h=10)

can_fc %>% autoplot() +
  autolayer(ec_can, Exports)

environmentName(environment(accuracy))

accuracy(can_fit)